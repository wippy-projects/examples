{{ extends "layout" }}

{{ block title() }}{{ data.title }}{{ end }}

{{ block styles() }}
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
           background: #0f0f1a; color: #cdd6f4; }
    .header { background: #11111b; color: #cdd6f4; padding: 12px 24px;
              display: flex; align-items: center; gap: 16px;
              border-bottom: 1px solid #313244; }
    .header h1 { font-size: 20px; font-weight: 600; color: #cba6f7; }
    button { padding: 6px 14px; border-radius: 6px; border: 1px solid #45475a;
             background: #313244; color: #cdd6f4; font-size: 13px; cursor: pointer; }
    button:hover { background: #45475a; }
    .toolbar { display: flex; align-items: center; gap: 8px; }
    .toolbar button.active { background: #6c47d6; border-color: #7c5ae0; color: #fff;
                             box-shadow: 0 0 8px rgba(108,71,214,0.4); }
    .toolbar select { padding: 6px 10px; border-radius: 6px; border: 1px solid #45475a;
                      background: #1e1e2e; color: #bac2de; font-size: 12px; outline: none; }
    .toolbar select:focus { border-color: #6c47d6; }
    .stats { color: #6c7086; font-size: 12px; margin-left: auto; }
    .content { display: flex; height: calc(100vh - 48px); }

    /* Panel 1: Sidebar */
    .sidebar { width: 260px; background: #181825; border-right: 1px solid #313244;
               display: flex; flex-direction: column; flex-shrink: 0; }
    .sidebar-toggle { display: flex; border-bottom: 1px solid #313244; }
    .sidebar-toggle button { flex: 1; border-radius: 0; background: #181825; color: #6c7086;
                             border: none; border-bottom: 2px solid transparent;
                             padding: 8px 10px; font-size: 12px; }
    .sidebar-toggle button:hover { background: #1e1e2e; color: #bac2de; }
    .sidebar-toggle button.active { color: #cba6f7; border-bottom-color: #cba6f7;
                                    font-weight: 600; background: #181825; }
    .tree { flex: 1; overflow-y: auto; padding: 8px 0; }
    .tree::-webkit-scrollbar { width: 6px; }
    .tree::-webkit-scrollbar-track { background: #181825; }
    .tree::-webkit-scrollbar-thumb { background: #313244; border-radius: 3px; }
    .tree::-webkit-scrollbar-thumb:hover { background: #45475a; }
    .tree-root { list-style: none; }
    .tree-folder { padding: 0; }
    .tree-folder-label { display: flex; align-items: center; gap: 4px;
                         padding: 5px 10px; font-size: 12px; font-weight: 600;
                         color: #a6adc8; cursor: pointer; user-select: none; }
    .tree-folder-label:hover { background: #1e1e2e; cursor: pointer; }
    .tree-folder-label.active { background: #2a2a4a; color: #cba6f7; }
    .tree-folder-label .icon { font-size: 10px; width: 12px; text-align: center;
                               transition: transform 0.15s; color: #585b70; }
    .tree-folder-label .icon.open { transform: rotate(90deg); }
    .tree-folder-label .count { color: #585b70; font-weight: 400; font-size: 11px; margin-left: auto; }
    .tree-files { list-style: none; padding-left: 12px; }
    .tree-file { padding: 3px 10px 3px 16px; font-size: 12px;
                 font-family: 'SF Mono', 'Fira Code', monospace;
                 color: #a6adc8; cursor: pointer; border-radius: 0;
                 transition: background 0.1s; list-style: none;
                 display: flex; align-items: center; gap: 6px; }
    .tree-file:hover { background: #1e1e2e; }
    .tree-file.active { background: #2a2a4a; font-weight: 600; color: #cba6f7; }
    .kind-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

    /* Panel 2: DOT Source */
    .dot-panel { width: 500px; background: #11111b; border-right: 1px solid #313244;
                 overflow: auto; flex-shrink: 0; display: flex; flex-direction: column; }
    .dot-panel::-webkit-scrollbar { width: 6px; }
    .dot-panel::-webkit-scrollbar-track { background: #11111b; }
    .dot-panel::-webkit-scrollbar-thumb { background: #313244; border-radius: 3px; }
    .dot-panel h3 { font-size: 11px; color: #585b70; padding: 10px 12px 6px;
                    text-transform: uppercase; letter-spacing: 0.5px; }
    .dot-panel pre { flex: 1; font-size: 11px; line-height: 1.5; color: #a6adc8;
                     padding: 0 12px 12px; margin: 0; white-space: pre-wrap;
                     word-break: break-all; font-family: 'JetBrains Mono', 'Fira Code', monospace; }

    /* Panel 3: Graph Render */
    .graph-wrapper { flex: 1; display: flex; flex-direction: column; overflow: hidden;
                     position: relative; }
    .graph-tabs { display: none; padding: 6px 16px 0; background: #181825;
                  border-bottom: 1px solid #313244; gap: 0; }
    .graph-tabs button { background: none; color: #6c7086; border: none;
                         border-bottom: 2px solid transparent;
                         padding: 6px 12px; font-size: 12px; border-radius: 0; cursor: pointer; }
    .graph-tabs button:hover { color: #bac2de; background: #1e1e2e; }
    .graph-tabs button.active { color: #cba6f7; border-bottom-color: #cba6f7; font-weight: 600; }
    .graph-area { flex: 1; overflow: hidden; background: #1e1e2e; position: relative; }
    .graph-area svg { width: 100%; height: 100%; }
    .graph-area svg > polygon { fill: #1e1e2e !important; }
    .graph-area svg g.node:hover { filter: brightness(1.15); }
    .zoom-controls { position: absolute; bottom: 12px; right: 12px; display: flex;
                     gap: 4px; z-index: 10; }
    .zoom-controls button { width: 32px; height: 32px; padding: 0; font-size: 16px;
                            background: #313244; color: #bac2de; border: 1px solid #45475a;
                            border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .zoom-controls button:hover { background: #45475a; color: #cdd6f4; }

    /* Legend */
    .legend { position: absolute; top: 12px; right: 12px; background: rgba(24,24,37,0.95);
              border: 1px solid #313244; border-radius: 8px; padding: 12px; z-index: 10;
              font-size: 11px; max-height: 60vh; overflow-y: auto; min-width: 180px;
              display: none; color: #a6adc8; }
    .legend-title { font-weight: 600; font-size: 12px; margin-bottom: 8px; color: #cdd6f4;
                    display: flex; justify-content: space-between; align-items: center; }
    .legend-close { background: none; border: none; color: #585b70; font-size: 16px;
                    cursor: pointer; padding: 0 4px; width: auto; height: auto; }
    .legend-close:hover { color: #cdd6f4; background: none; }
    .legend-subtitle { font-weight: 600; color: #585b70; font-size: 10px;
                       text-transform: uppercase; margin: 8px 0 4px; letter-spacing: 0.5px; }
    .legend-item { display: flex; align-items: center; gap: 6px; padding: 2px 0; cursor: pointer; }
    .legend-item:hover { background: rgba(108,71,214,0.15); }
    .legend-item.dimmed { opacity: 0.3; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; }
    .legend-line { width: 20px; height: 0; flex-shrink: 0; }
    .legend-toggle { position: absolute; top: 12px; right: 12px; width: 32px; height: 32px;
                     padding: 0; font-size: 16px; background: #313244; color: #bac2de;
                     border: 1px solid #45475a; border-radius: 6px; z-index: 9;
                     box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .legend-toggle:hover { background: #45475a; color: #cdd6f4; }

    .loading { color: #585b70; font-size: 14px; padding: 40px; }
    .error { color: #f38ba8; font-size: 13px; padding: 16px;
             background: rgba(243,139,168,0.1); border: 1px solid rgba(243,139,168,0.2);
             border-radius: 6px; margin: 16px; }

    /* Export buttons */
    .toolbar .export-btn { background: #1e1e2e; border-color: #45475a; font-size: 11px; padding: 5px 10px; }
    .toolbar .export-btn:hover { background: #313244; }

    /* Path finding */
    .graph-area svg g.node { cursor: pointer; transition: opacity 0.2s; }
    .graph-area svg g.edge { transition: opacity 0.2s; }
    .graph-area svg g.node.path-start polygon,
    .graph-area svg g.node.path-start ellipse { stroke: #89b4fa !important; stroke-width: 3px !important; }
    .mode-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
                      background: rgba(108,71,214,0.92); color: #fff; padding: 10px 20px;
                      border-radius: 8px; font-size: 13px; z-index: 20;
                      display: none; pointer-events: none;
                      box-shadow: 0 4px 16px rgba(0,0,0,0.4); }
    .mode-indicator.visible { display: block; }
</style>
{{ end }}

{{ block body() }}
<div class="header">
    <h1>{{ data.title }}</h1>
    <div class="toolbar">
        <button class="active" id="btn-full" onclick="loadFullGraph()">Full Graph</button>
        <button id="btn-orphans" onclick="loadOrphans()">Orphans</button>
        <select id="kind-filter" onchange="loadByKind(this.value)">
            <option value="">All Kinds</option>
            {{ range data.kinds }}
            <option value="{{ .kind }}">{{ .kind }} ({{ .count }})</option>
            {{ end }}
        </select>
        <select id="ns-filter" onchange="loadByNs(this.value)">
            <option value="">All Namespaces</option>
            {{ range data.namespaces }}
            <option value="{{ .ns }}">{{ .ns }} ({{ .count }})</option>
            {{ end }}
        </select>
        <button id="btn-path" onclick="togglePathFinding()">Find Path</button>
        <button class="export-btn" onclick="exportSVG()" title="Download SVG">â†“ SVG</button>
        <button class="export-btn" onclick="copyDOT()" title="Copy DOT">ðŸ“‹ DOT</button>
        <span id="stats" class="stats"></span>
    </div>
</div>
<div class="content">
    <div class="sidebar">
        <div class="sidebar-toggle">
            <button class="active" id="btn-by-kind" onclick="switchGrouping('kind')">By Kind</button>
            <button id="btn-by-ns" onclick="switchGrouping('namespace')">By Namespace</button>
        </div>
        <div class="tree" id="tree">
            <div class="loading" style="padding:16px">Loading...</div>
        </div>
    </div>
    <div class="dot-panel">
        <h3>DOT Source</h3>
        <pre id="dot-src">Loading graph...</pre>
    </div>
    <div class="graph-wrapper">
        <div class="graph-tabs" id="graph-tabs">
            <button class="active" data-dir="both" onclick="switchDir(this)">Neighborhood</button>
            <button data-dir="out" onclick="switchDir(this)">Dependencies</button>
            <button data-dir="in" onclick="switchDir(this)">Dependents</button>
        </div>
        <div class="graph-area" id="graph">
            <div class="loading">Loading graph...</div>
        </div>
        <div class="mode-indicator" id="modeIndicator"></div>
        <button class="legend-toggle" onclick="toggleLegend()" title="Legend">â—‘</button>
        <div class="legend" id="legend">
            <div class="legend-title">Legend <button class="legend-close" onclick="toggleLegend()">Ã—</button></div>
            <div class="legend-section">
                <div class="legend-subtitle">Entry Kinds</div>
                <div id="legend-kinds"></div>
            </div>
            <div class="legend-section">
                <div class="legend-subtitle">Edge Categories</div>
                <div id="legend-edges"></div>
            </div>
        </div>
        <div class="zoom-controls" id="zoom-controls" style="display:none">
            <button onclick="zoomIn()" title="Zoom in">+</button>
            <button onclick="zoomOut()" title="Zoom out">&minus;</button>
            <button onclick="zoomReset()" title="Fit to view">&#8634;</button>
        </div>
    </div>
</div>
{{ end }}

{{ block scripts() }}
<script>
    var KINDS_DATA = [
        {{ range data.kinds }}
        {kind: "{{ .kind }}", count: {{ .count }}},
        {{ end }}
    ];
    var NS_DATA = [
        {{ range data.namespaces }}
        {ns: "{{ .ns }}", count: {{ .count }}},
        {{ end }}
    ];

    var KIND_COLORS = {
        "http.service": {fill: "#3b1c1c", border: "#ef4444"},
        "http.router": {fill: "#3b2a14", border: "#f97316"},
        "http.endpoint": {fill: "#3b3514", border: "#eab308"},
        "function.lua": {fill: "#14331e", border: "#22c55e"},
        "process.lua": {fill: "#1a2740", border: "#3b82f6"},
        "process.service": {fill: "#221a40", border: "#6366f1"},
        "process.host": {fill: "#2a1a40", border: "#8b5cf6"},
        "library.lua": {fill: "#263314", border: "#84cc16"},
        "db.sql.sqlite": {fill: "#2a1a3b", border: "#a855f7"},
        "db.sql.postgres": {fill: "#2a1a3b", border: "#a855f7"},
        "store.memory": {fill: "#143033", border: "#06b6d4"},
        "queue.driver.memory": {fill: "#3b1430", border: "#ec4899"},
        "queue.queue": {fill: "#331a2e", border: "#f472b6"},
        "queue.consumer": {fill: "#331a22", border: "#fb7185"},
        "template.set": {fill: "#262524", border: "#a8a29e"},
        "template.jet": {fill: "#2a2928", border: "#d6d3d1"},
        "ns.dependency": {fill: "#1a1e33", border: "#818cf8"},
        "registry.entry": {fill: "#222233", border: "#9ca3af"},
        "workflow.lua": {fill: "#332e14", border: "#ca8a04"},
        "fs.directory": {fill: "#1e2430", border: "#64748b"},
        "env.storage.file": {fill: "#2a2014", border: "#d97706"},
        "env.variable": {fill: "#2a2214", border: "#f59e0b"},
        "exec.native": {fill: "#1e2430", border: "#94a3b8"},
        "ns.definition": {fill: "#1a1e33", border: "#a5b4fc"},
        "ns.requirement": {fill: "#1a1e33", border: "#c084fc"},
        "contract.binding": {fill: "#14332e", border: "#14b8a6"},
    };

    var CATEGORY_COLORS = {
        http: "#ef4444",
        runtime: "#3b82f6",
        queue: "#ec4899",
        storage: "#a855f7",
        template: "#a8a29e",
        temporal: "#f59e0b",
        "import": "#059669",
        lifecycle: "#9ca3af",
        dependency: "#6366f1",
        contract: "#14b8a6",
        env: "#d97706",
        hidden: "#f472b6",
        views: "#f97316",
        unknown: "#888888",
    };
</script>
<script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
<script type="module">
    import * as Viz from "https://cdn.jsdelivr.net/npm/@viz-js/viz/+esm";

    // Base path for API calls â€” works under any router prefix (e.g. /graph)
    const BASE = window.location.pathname.replace(/\/+$/, '');

    let viz = null;
    let panZoom = null;
    let allEntries = [];
    let currentGrouping = "kind";
    let currentEntry = null;
    let currentDir = "both";

    // Client-side graph interaction state
    let graphNodes = new Map();   // id -> SVG g element
    let graphEdges = [];          // {source, target, element}
    let inEdgeMap = new Map();    // target -> [{source, element}]
    let outEdgeMap = new Map();   // source -> [{target, element}]
    let highlightedNode = null;
    let pathFindingMode = false;
    let pathStartNode = null;
    let highlightDepth = 2;

    async function initViz() {
        if (!viz) viz = await Viz.instance();
        return viz;
    }

    // â”€â”€ Tree building â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function getKindColor(kind) {
        const c = KIND_COLORS[kind];
        return c ? c.border : "#9ca3af";
    }

    window.toggleFolder = function(iconEl) {
        iconEl.classList.toggle('open');
        var files = iconEl.closest('.tree-folder-label').nextElementSibling;
        files.style.display = iconEl.classList.contains('open') ? '' : 'none';
    }

    function buildTreeByKind(entries) {
        const groups = {};
        entries.forEach(e => {
            if (!groups[e.kind]) groups[e.kind] = [];
            groups[e.kind].push(e);
        });
        const sortedKinds = Object.keys(groups).sort();
        let html = '<ul class="tree-root">';
        sortedKinds.forEach(kind => {
            const items = groups[kind].sort((a, b) => a.name.localeCompare(b.name));
            html += '<li class="tree-folder">';
            html += '<div class="tree-folder-label" data-kind="' + kind + '">';
            html += '<span class="icon open" onclick="event.stopPropagation();toggleFolder(this)">&#9654;</span>';
            html += '<span class="kind-dot" style="background:' + getKindColor(kind) + '"></span> ' + kind;
            html += '<span class="count">' + items.length + '</span>';
            html += '</div>';
            html += '<ul class="tree-files">';
            items.forEach(e => {
                html += '<li class="tree-file" data-entry="' + e.id + '">';
                html += '<span class="kind-dot" style="background:' + getKindColor(e.kind) + '"></span>';
                html += e.name;
                html += '</li>';
            });
            html += '</ul></li>';
        });
        html += '</ul>';
        return html;
    }

    function buildTreeByNs(entries) {
        const groups = {};
        entries.forEach(e => {
            if (!groups[e.ns]) groups[e.ns] = [];
            groups[e.ns].push(e);
        });
        const sortedNs = Object.keys(groups).sort();
        let html = '<ul class="tree-root">';
        sortedNs.forEach(ns => {
            const items = groups[ns].sort((a, b) => a.name.localeCompare(b.name));
            html += '<li class="tree-folder">';
            html += '<div class="tree-folder-label" data-ns="' + ns + '">';
            html += '<span class="icon open" onclick="event.stopPropagation();toggleFolder(this)">&#9654;</span>';
            html += '&#128193; ' + ns;
            html += '<span class="count">' + items.length + '</span>';
            html += '</div>';
            html += '<ul class="tree-files">';
            items.forEach(e => {
                html += '<li class="tree-file" data-entry="' + e.id + '">';
                html += '<span class="kind-dot" style="background:' + getKindColor(e.kind) + '"></span>';
                html += e.name;
                html += '</li>';
            });
            html += '</ul></li>';
        });
        html += '</ul>';
        return html;
    }

    function updateTree() {
        const tree = document.getElementById("tree");
        if (allEntries.length === 0) {
            tree.innerHTML = '<div class="loading" style="padding:16px">No entries</div>';
            return;
        }
        tree.innerHTML = currentGrouping === "kind"
            ? buildTreeByKind(allEntries)
            : buildTreeByNs(allEntries);
        tree.querySelectorAll(".tree-file").forEach(li => {
            li.addEventListener("click", () => {
                currentEntry = li.dataset.entry;
                currentDir = "both";
                document.querySelectorAll(".tree-file").forEach(x => x.classList.remove("active"));
                document.querySelectorAll(".tree-folder-label").forEach(x => x.classList.remove("active"));
                li.classList.add("active");
                // Client-side highlight if node exists in current graph, else server fetch
                if (graphNodes.has(currentEntry)) {
                    showGraphTabs(currentDir);
                    highlightEntry(currentEntry, currentDir);
                } else {
                    loadEntryGraph(currentEntry, currentDir);
                }
            });
        });
        tree.querySelectorAll(".tree-folder-label").forEach(lbl => {
            lbl.addEventListener("click", () => {
                currentEntry = null;
                document.querySelectorAll(".tree-file").forEach(x => x.classList.remove("active"));
                document.querySelectorAll(".tree-folder-label").forEach(x => x.classList.remove("active"));
                lbl.classList.add("active");
                document.getElementById("graph-tabs").style.display = "none";
                if (lbl.dataset.ns) {
                    setActiveToolbar(null);
                    fetchAndRenderGraph(BASE + "/api/graph?ns=" + encodeURIComponent(lbl.dataset.ns));
                } else if (lbl.dataset.kind) {
                    setActiveToolbar(null);
                    fetchAndRenderGraph(BASE + "/api/graph?kind=" + encodeURIComponent(lbl.dataset.kind));
                }
            });
        });
    }

    async function loadEntries() {
        try {
            const res = await fetch(BASE + "/api/entries");
            const data = await res.json();
            allEntries = data.entries || [];
            updateTree();
        } catch(e) {
            document.getElementById("tree").innerHTML = '<div class="error">Failed to load entries</div>';
        }
    }

    window.switchGrouping = function(mode) {
        currentGrouping = mode;
        document.getElementById("btn-by-kind").classList.toggle("active", mode === "kind");
        document.getElementById("btn-by-ns").classList.toggle("active", mode === "namespace");
        updateTree();
    };

    // â”€â”€ Graph rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function showDot(dot) {
        document.getElementById("dot-src").textContent = dot;
    }

    async function renderDot(dot) {
        const area = document.getElementById("graph");
        showDot(dot);
        if (panZoom) { panZoom.destroy(); panZoom = null; }
        try {
            const v = await initViz();
            const svg = v.renderSVGElement(dot);
            area.innerHTML = "";
            svg.removeAttribute("width");
            svg.removeAttribute("height");
            svg.style.width = "100%";
            svg.style.height = "100%";
            area.appendChild(svg);
            panZoom = svgPanZoom(svg, {
                zoomEnabled: true, controlIconsEnabled: false,
                fit: true, center: true, minZoom: 0.1, maxZoom: 20,
                zoomScaleSensitivity: 0.3
            });
            document.getElementById("zoom-controls").style.display = "flex";
            parseGraphData(svg);
            wireInteractions(svg);
        } catch(e) {
            area.innerHTML = '<div class="error">Render error: ' + e.message + '</div>';
        }
    }

    // â”€â”€ Parse SVG graph structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function parseGraphData(svg) {
        graphNodes = new Map();
        graphEdges = [];
        inEdgeMap = new Map();
        outEdgeMap = new Map();

        // Parse nodes
        svg.querySelectorAll("g.node").forEach(g => {
            var title = g.querySelector("title");
            if (!title) return;
            var id = title.textContent.trim();
            graphNodes.set(id, g);
        });

        // Parse edges: each g.edge has a <title> like "source->target"
        svg.querySelectorAll("g.edge").forEach(g => {
            var title = g.querySelector("title");
            if (!title) return;
            var parts = title.textContent.trim().split("->");
            if (parts.length !== 2) return;
            var source = parts[0].trim();
            var target = parts[1].trim();
            var edge = { source: source, target: target, element: g };
            graphEdges.push(edge);
            if (!inEdgeMap.has(target)) inEdgeMap.set(target, []);
            inEdgeMap.get(target).push(edge);
            if (!outEdgeMap.has(source)) outEdgeMap.set(source, []);
            outEdgeMap.get(source).push(edge);
        });
    }

    // â”€â”€ Client-side highlight (BFS neighbor traversal) â”€â”€â”€â”€â”€

    function highlightEntry(entryId, direction) {
        highlightedNode = entryId;
        var depth = highlightDepth;

        var connected = new Set([entryId]);
        var connectedEdges = new Set();

        // Traverse upstream (incoming edges)
        if (direction !== "out") {
            var queue = [{ id: entryId, d: 0 }];
            while (queue.length) {
                var item = queue.shift();
                if (item.d >= depth) continue;
                var incoming = inEdgeMap.get(item.id) || [];
                for (var i = 0; i < incoming.length; i++) {
                    var e = incoming[i];
                    connectedEdges.add(e.element);
                    if (!connected.has(e.source)) {
                        connected.add(e.source);
                        queue.push({ id: e.source, d: item.d + 1 });
                    }
                }
            }
        }

        // Traverse downstream (outgoing edges)
        if (direction !== "in") {
            var queue2 = [{ id: entryId, d: 0 }];
            while (queue2.length) {
                var item2 = queue2.shift();
                if (item2.d >= depth) continue;
                var outgoing = outEdgeMap.get(item2.id) || [];
                for (var j = 0; j < outgoing.length; j++) {
                    var e2 = outgoing[j];
                    connectedEdges.add(e2.element);
                    if (!connected.has(e2.target)) {
                        connected.add(e2.target);
                        queue2.push({ id: e2.target, d: item2.d + 1 });
                    }
                }
            }
        }

        // Apply opacity
        graphNodes.forEach(function(g, id) {
            g.style.opacity = connected.has(id) ? "1" : "0.12";
        });
        graphEdges.forEach(function(edge) {
            edge.element.style.opacity = connectedEdges.has(edge.element) ? "1" : "0.06";
        });

        // Update sidebar highlight
        document.querySelectorAll(".tree-file").forEach(x => {
            x.classList.toggle("active", x.dataset.entry === entryId);
        });
        document.querySelectorAll(".tree-folder-label").forEach(x => x.classList.remove("active"));
    }

    function resetHighlight() {
        highlightedNode = null;
        graphNodes.forEach(function(g) { g.style.opacity = "1"; });
        graphEdges.forEach(function(edge) { edge.element.style.opacity = "1"; });
        // Remove path-start class
        graphNodes.forEach(function(g) { g.classList.remove("path-start"); });
    }

    // â”€â”€ Path finding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function findAndHighlightPath(startId, endId) {
        if (startId === endId) {
            showModeMessage("Start and end are the same node");
            return;
        }

        // BFS bidirectional adjacency
        var adjacency = new Map();
        graphEdges.forEach(function(e) {
            if (!adjacency.has(e.source)) adjacency.set(e.source, []);
            if (!adjacency.has(e.target)) adjacency.set(e.target, []);
            adjacency.get(e.source).push({ node: e.target, edge: e.element });
            adjacency.get(e.target).push({ node: e.source, edge: e.element });
        });

        var queue = [{ node: startId, path: [startId], edges: [] }];
        var visited = new Set([startId]);

        while (queue.length) {
            var cur = queue.shift();
            if (cur.node === endId) {
                // Highlight the path
                var pathSet = new Set(cur.path);
                var edgeSet = new Set(cur.edges);
                graphNodes.forEach(function(g, id) {
                    g.style.opacity = pathSet.has(id) ? "1" : "0.1";
                });
                graphEdges.forEach(function(edge) {
                    edge.element.style.opacity = edgeSet.has(edge.element) ? "1" : "0.05";
                });
                showModeMessage("Path: " + cur.path.length + " nodes, " + cur.edges.length + " edges");
                return;
            }
            var neighbors = adjacency.get(cur.node) || [];
            for (var i = 0; i < neighbors.length; i++) {
                var nb = neighbors[i];
                if (!visited.has(nb.node)) {
                    visited.add(nb.node);
                    queue.push({
                        node: nb.node,
                        path: cur.path.concat([nb.node]),
                        edges: cur.edges.concat([nb.edge])
                    });
                }
            }
        }

        showModeMessage("No path found between nodes");
        resetHighlight();
    }

    function showModeMessage(msg) {
        var el = document.getElementById("modeIndicator");
        el.textContent = msg;
        el.classList.add("visible");
        setTimeout(function() { el.classList.remove("visible"); }, 2500);
    }

    window.togglePathFinding = function() {
        pathFindingMode = !pathFindingMode;
        pathStartNode = null;
        var btn = document.getElementById("btn-path");
        btn.classList.toggle("active", pathFindingMode);
        var indicator = document.getElementById("modeIndicator");
        if (pathFindingMode) {
            resetHighlight();
            indicator.textContent = "Click first node to start path";
            indicator.classList.add("visible");
        } else {
            indicator.classList.remove("visible");
            resetHighlight();
        }
    };

    function cancelPathFinding() {
        pathFindingMode = false;
        pathStartNode = null;
        document.getElementById("btn-path").classList.remove("active");
        document.getElementById("modeIndicator").classList.remove("visible");
        graphNodes.forEach(function(g) { g.classList.remove("path-start"); });
    }

    function handlePathClick(nodeId, nodeEl) {
        var indicator = document.getElementById("modeIndicator");
        if (!pathStartNode) {
            pathStartNode = nodeId;
            nodeEl.classList.add("path-start");
            indicator.textContent = "Now click the destination node";
        } else {
            findAndHighlightPath(pathStartNode, nodeId);
            cancelPathFinding();
        }
    }

    // â”€â”€ Wire SVG interactions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function wireInteractions(svg) {
        // Node clicks
        svg.querySelectorAll("g.node").forEach(function(g) {
            var title = g.querySelector("title");
            if (!title) return;
            var entryId = title.textContent.trim();
            g.style.cursor = "pointer";
            g.addEventListener("click", function(e) {
                e.stopPropagation();
                if (pathFindingMode) {
                    handlePathClick(entryId, g);
                    return;
                }
                currentEntry = entryId;
                currentDir = "both";
                showGraphTabs(currentDir);
                highlightEntry(entryId, currentDir);
            });
        });

        // Background click resets
        svg.addEventListener("click", function(e) {
            if (e.target === svg || e.target.tagName === "svg") {
                resetHighlight();
                currentEntry = null;
                document.getElementById("graph-tabs").style.display = "none";
                document.querySelectorAll(".tree-file").forEach(x => x.classList.remove("active"));
                if (pathFindingMode) cancelPathFinding();
            }
        });
    }

    function showGraphTabs(dir) {
        var tabs = document.getElementById("graph-tabs");
        tabs.style.display = "flex";
        tabs.querySelectorAll("button").forEach(function(b) {
            b.classList.toggle("active", b.dataset.dir === dir);
        });
    }

    // Escape key resets
    document.addEventListener("keydown", function(e) {
        if (e.key === "Escape") {
            if (pathFindingMode) { cancelPathFinding(); return; }
            resetHighlight();
            currentEntry = null;
            document.getElementById("graph-tabs").style.display = "none";
            document.querySelectorAll(".tree-file").forEach(x => x.classList.remove("active"));
        }
    });

    window.zoomIn = function() { if (panZoom) panZoom.zoomIn(); };
    window.zoomOut = function() { if (panZoom) panZoom.zoomOut(); };
    window.zoomReset = function() { if (panZoom) { panZoom.resetZoom(); panZoom.resetPan(); panZoom.fit(); panZoom.center(); } };

    // â”€â”€ Graph loading functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function updateStats(dot) {
        const nodeCount = (dot.match(/"\S+?" \[/g) || []).length;
        const edgeCount = (dot.match(/->/g) || []).length;
        document.getElementById("stats").textContent = nodeCount + " entries Â· " + edgeCount + " edges";
    }

    function setActiveToolbar(id) {
        ["btn-full", "btn-orphans"].forEach(b => document.getElementById(b).classList.remove("active"));
        if (id) document.getElementById(id).classList.add("active");
        document.getElementById("kind-filter").value = "";
        document.getElementById("ns-filter").value = "";
    }

    async function fetchAndRenderGraph(url) {
        const area = document.getElementById("graph");
        area.innerHTML = '<div class="loading">Building graph...</div>';
        try {
            const res = await fetch(url);
            const dot = await res.text();
            if (!res.ok) { area.innerHTML = '<div class="error">' + dot + '</div>'; return; }
            await renderDot(dot);
            updateStats(dot);
        } catch(e) {
            area.innerHTML = '<div class="error">Error: ' + e.message + '</div>';
        }
    }

    window.loadFullGraph = function() {
        currentEntry = null;
        setActiveToolbar("btn-full");
        document.getElementById("graph-tabs").style.display = "none";
        document.querySelectorAll(".tree-file").forEach(x => x.classList.remove("active"));
        fetchAndRenderGraph(BASE + "/api/graph");
    };

    window.loadOrphans = function() {
        currentEntry = null;
        setActiveToolbar("btn-orphans");
        document.getElementById("graph-tabs").style.display = "none";
        fetchAndRenderGraph(BASE + "/api/graph?orphans=true");
    };

    window.loadByKind = function(kind) {
        currentEntry = null;
        setActiveToolbar(null);
        document.getElementById("kind-filter").value = kind;
        document.getElementById("graph-tabs").style.display = "none";
        if (!kind) { loadFullGraph(); return; }
        fetchAndRenderGraph(BASE + "/api/graph?kind=" + encodeURIComponent(kind));
    };

    window.loadByNs = function(ns) {
        currentEntry = null;
        setActiveToolbar(null);
        document.getElementById("ns-filter").value = ns;
        document.getElementById("graph-tabs").style.display = "none";
        if (!ns) { loadFullGraph(); return; }
        fetchAndRenderGraph(BASE + "/api/graph?ns=" + encodeURIComponent(ns));
    };

    async function loadEntryGraph(entryId, dir) {
        setActiveToolbar(null);
        showGraphTabs(dir);
        let url = BASE + "/api/graph?entry=" + encodeURIComponent(entryId) + "&depth=3";
        if (dir && dir !== "both") url += "&dir=" + dir;
        fetchAndRenderGraph(url);
    }

    window.switchDir = function(btn) {
        if (!currentEntry) return;
        currentDir = btn.dataset.dir;
        // Use client-side highlighting if node is in the current graph
        if (graphNodes.has(currentEntry)) {
            showGraphTabs(currentDir);
            highlightEntry(currentEntry, currentDir);
        } else {
            loadEntryGraph(currentEntry, currentDir);
        }
    };

    // â”€â”€ Legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window.toggleLegend = function() {
        const legend = document.getElementById("legend");
        legend.style.display = legend.style.display === "none" ? "block" : "none";
    };

    function updateLegend() {
        const kindsEl = document.getElementById("legend-kinds");
        const edgesEl = document.getElementById("legend-edges");

        const activeKinds = [...new Set(allEntries.map(e => e.kind))].sort();
        kindsEl.innerHTML = activeKinds.map(k => {
            const c = KIND_COLORS[k] || {fill: "#e5e7eb", border: "#9ca3af"};
            return '<div class="legend-item" data-kind="' + k + '">' +
                '<span class="legend-swatch" style="background:' + c.fill + ';border-color:' + c.border + '"></span>' +
                k + '</div>';
        }).join("");

        const categories = Object.keys(CATEGORY_COLORS).sort();
        edgesEl.innerHTML = categories.map(cat => {
            const color = CATEGORY_COLORS[cat];
            return '<div class="legend-item" data-cat="' + cat + '">' +
                '<span class="legend-line" style="border-top:2px solid ' + color + '"></span>' +
                cat + '</div>';
        }).join("");
    }

    // â”€â”€ Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window.exportSVG = function() {
        const svg = document.querySelector('.graph-area svg');
        if (!svg) return;
        const blob = new Blob([svg.outerHTML], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'registry-graph.svg'; a.click();
        URL.revokeObjectURL(url);
    };

    window.copyDOT = function() {
        const dot = document.getElementById('dot-src').textContent;
        navigator.clipboard.writeText(dot).then(() => {
            const btn = event.target;
            const orig = btn.textContent;
            btn.textContent = "Copied";
            setTimeout(() => btn.textContent = orig, 1500);
        });
    };

    // â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    loadEntries().then(() => {
        updateLegend();
        loadFullGraph();
    });
</script>
{{ end }}
